<!DOCTYPE html>
<html lang="en">
<head>
  <base href="../../">

  <title>Developer Testing</title>

  <link href="examples/style.css" rel="stylesheet">
  <link href="build/cookieconsent.min.css" rel="stylesheet">

  <style>
    /* these exist only to display more than 2 banners on a page */
    .cc-top1{top: 5em;}
    .cc-bottom1{bottom: 5em;}
  </style>

<body role="document">

  <div class="example-window">
    <h1>Testing banner popups</h1>
    <p>Look at all the layouts on screen and see if any look wrong</p>

    <select id="theme" class="selectbox"></select>
    <select id="palette" class="selectbox"></select>

    <br><br>

    <button onclick="javascript: window.location = 'examples/tests/test-floating.html';">Next test</button>
  </div>


<script src="build/cookieconsent.min.js"></script>
<script>

  // We are gonna have multiple popups on the page (to display many variations).

  // Normany, each window exists within a wrapper element. We can either create the first popup element and use it's wrapper
  // over and over again OR we can create the wrapper once at the beginning, and continuously recycle it for each popup

  var $wrapper = cookieconsent.Popup.getNewWrapper();

  var defaultOptions = {
    // Make it so each popup always uses the $wrapper container
    container: $wrapper,

    // The app automatically prepends the popup to a wrapper (because most cases want the wrapper by default)
    // This tells the app not to prepend the wrapper, so it prepends the popup window instead
    useWrapper: false
  };

  var popupInstances = [
    cookieconsent.factory(defaultOptions),
    cookieconsent.factory(defaultOptions),
    cookieconsent.factory(defaultOptions),
    cookieconsent.factory(defaultOptions),
  ];

  var $theme = document.getElementById('theme');
  var $palette = document.getElementById('palette');

  var PALETTES = cookieconsent.Popup.getPalettes();
  var THEMES = cookieconsent.Popup.getThemes()
    .filter(function(cur){return /\-banner$/.test(cur)});

  var arrayToSelectboxOptions = function(v, k) {
    return '<option value="' + v + '">' + pretty(v) + '</option>'
  };

  fillSelect($theme, THEMES, arrayToSelectboxOptions);
  fillSelect($palette, PALETTES, arrayToSelectboxOptions);

  $theme.onchange = function (e) { update() };
  $palette.onchange = function (e) { update() };

  update();

  document.body.insertBefore($wrapper, document.body.firstChild);



  function getInputs () {
    return {
      theme: $theme[$theme.selectedIndex].value,
      palette: $palette[$palette.selectedIndex].value,
    }
  }

  function getOptions (inputs) {
    return {
      theme: inputs.theme,
      palette: inputs.palette,
    }
  }

  function draw(opts) {
    popupInstances[0].initialise(Object.assign({}, defaultOptions, opts, {type: 'dismiss', position: 'banner-top'})).open();
    popupInstances[1].initialise(Object.assign({}, defaultOptions, opts, {type: 'info',    position: 'banner-top1'})).open();
    popupInstances[2].initialise(Object.assign({}, defaultOptions, opts, {type: 'opt-in',  position: 'banner-bottom1'})).open();
    popupInstances[3].initialise(Object.assign({}, defaultOptions, opts, {type: 'opt-out', position: 'banner-bottom'})).open();
  }

  function update () {
    draw(getOptions(getInputs()));
  }

  function pretty (str) {
    return str[0].toUpperCase() + str.slice(1).replace(/\-/g, ' ');
  }

  function fillSelect (select, options, cb) {
    var html = '';
    if (typeof cb != 'function') {
      cb = function(v, k) { return '<option value="' + k + '">' + v + '</option>' };
    }
    for (var prop in options) {
      html += cb(options[prop], prop);
    }
    select.innerHTML = html;
  }

</script>
